#!/usr/bin/perl -w

use strict;
use lib qw(.);
use Memory::Usage;
use XML::Twig;
use Data::Dumper;
use Getopt::Long;
use Cwd;
use ScarfXmlReader;
use SarifJsonWriter;
use SarifJsonWriter qw(CheckStart CheckBug);

my $progName = "SWAMP SARIF Translator";
my $version = '0.8.0';

# PrintUsage: Prints a usage message
sub PrintUsage {
    my $programName = $0;
    $programName =~ s/.*[\\\/]//;

    print STDERR <<EOF;
Usage: $programName [options]

options:
    --help                         -h print this message
    --version                      -v print version
    --compact                      -c print compactly (no indents)
    --scarf=<FILE>                 -x path to scarf file
    --summary=<FILE>               -s path to assessment_summary file
    --hashes=<FILE>                -l path to file containing list of hashes
    --build=<DIR>                  -b path to build directory
    --output=<FILE>                -o output file name/path
EOF
}

# PrintVersion - Print the version of the program
#
sub PrintVersion {
    my $progName = $0;

    $progName =~ s/.*(\\\/)//;
    print "$progName version $version\n";
}

sub ProcessOptions {
    my %optionDefaults = (
        help => 0,
        compact => 1,
    );

    my @options = (
        "help|h!",
        "version|v!",
        "compact|c!",
        "scarf|x=s",
        "summary|s=s",
        "hashes|l=s",
        "build|b=s",
        "output|o=s",
    );

    Getopt::Long::Configure(qw/require_order no_ignore_case no_auto_abbrev/);
    my %getoptOptions;
    my $ok = GetOptions(\%getoptOptions, @options);

    my %options = %optionDefaults;
    while (my ($k, $v) = each %getoptOptions) {
        if ($k eq "compact") {
            $options{$k} = 0;
        } else {
            $options{$k} = $v;
        }
    }

    my @errs;

    if (!$ok || $options{help}) {
        PrintUsage(\%optionDefaults);
        exit !$ok;
    }

    if ($ok && $options{version}) {
        PrintVersion();
        exit 0;
    }

    push @errs, "scarf file not provided" unless exists $options{scarf};
    push @errs, "output file name/path not provided" unless exists $options{output};
 
    if (@errs) {
        print STDERR "$0: options Errors:\n    ", join ("\n    ", @errs), "\n";
        exit 1;
    }

    return \%options;
}

sub ReadAssessmentSummary {
    my ($summaryFile) = @_;
    my %hash;
    my $assessment = {};

    my $t = XML::Twig->new(
        twig_handlers => {
            'assessment-summary/assessment-artifacts/assessment' => sub {
                my ($twig, $e) = @_;
                $hash{$assessment->{'build-artifact-id'}} = $assessment;
                $assessment = {};
                $twig->purge();
            },
            'assessment-summary/assessment-artifacts/assessment/build-artifact-id' => sub {
                my ($twig, $e) = @_;
                $assessment->{'build-artifact-id'} = GetText($e);
            },
            'assessment-summary/assessment-artifacts/assessment/report' => sub {
                my ($twig, $e) = @_;
                $assessment->{report} = GetText($e);
            },
            'assessment-summary/assessment-artifacts/assessment/exit-code' => sub {
                my ($twig, $e) = @_;
                $assessment->{exitCode} = GetText($e);
            },
            'assessment-summary/assessment-artifacts/assessment/start-ts' => sub {
                my ($twig, $e) = @_;
                $assessment->{startTime} = ConvertEpoch(GetText($e));
            },
            # FIXME: There is no need for the following block since it should be stop-ts
            'assessment-summary/assessment-artifacts/assessment/end-ts' => sub {
                my ($twig, $e) = @_;
                $assessment->{endTime} = ConvertEpoch(GetText($e));
            },
            'assessment-summary/assessment-artifacts/assessment/stop-ts' => sub {
                my ($twig, $e) = @_;
                $assessment->{endTime} = ConvertEpoch(GetText($e));
            },
            'assessment-summary/assessment-artifacts/assessment/command/cwd' => sub {
                my ($twig, $e) = @_;
                $assessment->{workingDirectory} = GetText($e);
            },
            'assessment-summary/assessment-artifacts/assessment/command/environment/env' => sub {
                my ($twig, $e) = @_;
                my $string = GetText($e);
                if ($string =~ /(.+)=(.*)/) {
                    if (exists $assessment->{env}{$1}) {
                        die "env $1 already exists";
                    }
                    $assessment->{env}{$1} = $2;
                }
                else {
                    print "Error parsing env $string\n";
                }
            },
            'assessment-summary/assessment-artifacts/assessment/command/executable' => sub {
                my ($twig, $e) = @_;
                $assessment->{commandLine} = GetText($e);
            },
            'assessment-summary/assessment-artifacts/assessment/command/args/arg' => sub {
                my ($twig, $e) = @_;
                push @{$assessment->{args}}, GetText($e);
            },
        }
    );
    $t->parsefile($summaryFile);
    return \%hash;
}

sub ReadHashFile {
    my ($filename) = @_;
    my %hash;

    open (my $fh, '<', $filename) or die "Can't open hash file $filename: $!";

    foreach (<$fh>) {
        if (/(.+)\s(.+)/) {
            $hash{$2} = $1;
        } else {
            die "Error parsing hash file";
        }
    }

    close $fh;
    return \%hash;
}

sub InitialFunction {
    my ($initialData, $data) = @_;

    $initialData->{conversion}{tool_name} = $progName;
    $initialData->{conversion}{tool_version} = $version;
    $initialData->{conversion}{commandLine} = $0;
    $initialData->{conversion}{argv} = $data->{argv};
    $initialData->{conversion}{workingDirectory} = getcwd();
    foreach (keys %ENV) {
        $initialData->{conversion}{env}{$_} = $ENV{$_};
    }
    $initialData->{conversion}{startTime} = $data->{startTime};

    if ($data->{options}{hashes}) {
        $initialData->{sha256hashes} = ReadHashFile($data->{options}{hashes});
    }
    if ($data->{options}{summary}) {
        $initialData->{invocations} = ReadAssessmentSummary($data->{options}{summary});
    }
    if ($data->{options}{build}) {
        $initialData->{buildDir} = $data->{options}{build};
    }

    $data->{writer}->AddStartTag($initialData);
    return;
}

sub BugFunction {
    my ($bugData, $data) = @_;

    $data->{hasBug} = 1;
    $data->{writer}->AddBugInstance($bugData);

    return;
}

sub main {
    my $startTime = time();
    my $mu = Memory::Usage->new();
    $mu->record('start');

    my %data;

    push @{$data{argv}}, @ARGV;
    $data{startTime} = $startTime;
    $data{options} = ProcessOptions();

    my $reader = new ScarfXmlReader($data{options}{scarf});

    $data{writer} = new SarifJsonWriter($data{options}{output}, "utf-8");
    $data{writer}->SetPretty($data{options}{compact});

    $reader->SetInitialCallback(\&InitialFunction);
    $reader->SetBugCallback(\&BugFunction);

    $reader->SetCallbackData(\%data);
    $reader->Parse();

    $mu->record('end');
    #$mu->dump();

    $data{writer}->Close();

    if (!$data{hasBug}) {
        die "Has no bug";
    }
}

sub GetText {
    my ($e) = @_;

    if (!$e->contains_only_text()) {
        my $xpath = $e->xpath();
        die "Element $xpath must contain only text: $!";
    }
    
    return $e->text();
}

sub ConvertEpoch {
    my ($time) = @_;

    my $fraction;
    if ($time =~ /.+\.(.+)/) {
        $fraction = $1;
    }

    my ($sec, $min, $hour, $day, $month, $year) = gmtime($time);

    $year += 1900;
    $month += 1;

    if ($month < 10) {
        $month = "0".$month;
    }
    if ($day < 10) {
        $day = "0".$day;
    }
    if ($hour < 10) {
        $hour = "0".$hour;
    }
    if ($min < 10) {
        $min = "0".$min;
    }
    if ($sec < 10) {
        $sec = "0".$sec;
    }

    if ($fraction) {
        return "$year-$month-$day"."T"."$hour:$min:$sec.$fraction" . "Z";
    } else {
        return "$year-$month-$day"."T"."$hour:$min:$sec" . "Z";
    }
} 

main();
